# SAMP SDK

<div align="center">

![C++](https://img.shields.io/badge/C%2B%2B-14/17/20-00599C?style=for-the-badge&logo=cplusplus)
![Platform](https://img.shields.io/badge/Platform-Windows%20%7C%20Linux-blue?style=for-the-badge&logo=windows&logoColor=white)
![Architecture](https://img.shields.io/badge/Architecture-x86%20(32--bit)-lightgrey?style=for-the-badge)
![License](https://img.shields.io/badge/License-MIT-green?style=for-the-badge)

**Современный, header-only, высокоуровневый C++ SDK для разработки плагинов и модулей для SA-MP.**

</div>

## Языки

- Português: [README](../../)
- Deutsch: [README](../Deutsch/README.md)
- English: [README](../English/README.md)
- Español: [README](../Espanol/README.md)
- Français: [README](../Francais/README.md)
- Italiano: [README](../Italiano/README.md)
- Polski: [README](../Polski/README.md)
- Svenska: [README](../Svenska/README.md)
- Türkçe: [README](../Turkce/README.md)

## Оглавление

- [SAMP SDK](#samp-sdk)
  - [Языки](#языки)
  - [Оглавление](#оглавление)
  - [1. Введение и философия дизайна](#1-введение-и-философия-дизайна)
    - [Проблема со стандартным C API SA-MP](#проблема-со-стандартным-c-api-sa-mp)
    - [Решение SAMP SDK: Абстракция с безопасностью и производительностью](#решение-samp-sdk-абстракция-с-безопасностью-и-производительностью)
    - [Модель Header-Only: Преимущества и последствия](#модель-header-only-преимущества-и-последствия)
  - [2. Настройка и окружение](#2-настройка-и-окружение)
    - [Требования к компиляции](#требования-к-компиляции)
    - [Рекомендуемая структура файлов](#рекомендуемая-структура-файлов)
    - [Основные макросы конфигурации\*\*](#основные-макросы-конфигурации)
      - [`SAMP_SDK_IMPLEMENTATION`](#samp_sdk_implementation)
      - [`SAMP_SDK_WANT_AMX_EVENTS`](#samp_sdk_want_amx_events)
      - [`SAMP_SDK_WANT_PROCESS_TICK`](#samp_sdk_want_process_tick)
    - [Определения и константы SA-MP (`samp_defs.hpp`)](#определения-и-константы-sa-mp-samp_defshpp)
  - [3. Подробное руководство по использованию API](#3-подробное-руководство-по-использованию-api)
    - [3.1. Жизненный цикл плагина](#31-жизненный-цикл-плагина)
      - [`bool OnLoad()`](#bool-onload)
      - [`void OnUnload()`](#void-onunload)
      - [`unsigned int GetSupportFlags()`](#unsigned-int-getsupportflags)
      - [`void OnAmxLoad(AMX* amx)`](#void-onamxloadamx-amx)
      - [`void OnAmxUnload(AMX* amx)`](#void-onamxunloadamx-amx)
      - [`void OnProcessTick()`](#void-onprocesstick)
    - [3.2. `Plugin_Public`: Перехват событий Pawn](#32-plugin_public-перехват-событий-pawn)
      - [Синтаксис и объявление](#синтаксис-и-объявление)
      - [Автоматический маршалинг параметров](#автоматический-маршалинг-параметров)
      - [Управление потоком: `PLUGIN_PUBLIC_CONTINUE` vs `PLUGIN_PUBLIC_STOP`](#управление-потоком-plugin_public_continue-vs-plugin_public_stop)
    - [3.3. `Plugin_Native`: Создание нативных функций на C++](#33-plugin_native-создание-нативных-функций-на-c)
      - [Синтаксис и фиксированная сигнатура](#синтаксис-и-фиксированная-сигнатура)
      - [Автоматическая регистрация нативов](#автоматическая-регистрация-нативов)
      - [Извлечение параметров: `Register_Parameters` vs. `Native_Params`](#извлечение-параметров-register_parameters-vs-native_params)
        - [`Register_Parameters(...)`](#register_parameters)
        - [`Native_Params` (Полный API: `Get`, `Get_REF`, `Set_REF`)](#native_params-полный-api-get-get_ref-set_ref)
          - [`p.Count()`](#pcount)
          - [`p.Get<T>(size_t index)`](#pgettsize_t-index)
          - [`p.Get_REF<T>(size_t index, T& out_value)`](#pget_reftsize_t-index-t-out_value)
          - [`p.Get_REF<T>(size_t index)` (C++17+)](#pget_reftsize_t-index-c17)
          - [`p.Set_REF<T>(size_t index, T value)`](#pset_reftsize_t-index-t-value)
      - [Возврат значений](#возврат-значений)
    - [3.4. `Pawn_*` Макросы: Вызов функций Pawn из C++](#34-pawn_-макросы-вызов-функций-pawn-из-c)
      - [`Pawn_Native(ИмяНатива, ...)`](#pawn_nativeимянатива-)
      - [`Pawn_Public(ИмяPublic, ...)`](#pawn_publicимяpublic-)
      - [`Pawn(ИмяФункции, ...)`](#pawnимяфункции-)
      - [Синтаксис и соглашения](#синтаксис-и-соглашения)
      - [Маршалинг входных параметров](#маршалинг-входных-параметров)
      - [Маршалинг выходных параметров (Ссылки: `int&`, `float&`, `std::string&`)](#маршалинг-выходных-параметров-ссылки-int-float-stdstring)
      - [Объект `Callback_Result`: Полный анализ](#объект-callback_result-полный-анализ)
      - [**3.5. `Plugin_Module`: Управление динамическими модулями**](#35-plugin_module-управление-динамическими-модулями)
      - [Синтаксис и назначение](#синтаксис-и-назначение)
      - [Жизненный цикл модуля](#жизненный-цикл-модуля)
      - [Преимущества модульности](#преимущества-модульности)
    - [3.6. `Plugin_Call`: Вызов внутренних нативов плагина](#36-plugin_call-вызов-внутренних-нативов-плагина)
      - [Синтаксис и преимущества производительности](#синтаксис-и-преимущества-производительности)
    - [**3.7. Утилиты SDK**](#37-утилиты-sdk)
      - [`Samp_SDK::Log(const char* format, ...)`](#samp_sdklogconst-char-format-)
      - [`std::string Plugin_Format(const char* format, ...)` (Рекомендуется)](#stdstring-plugin_formatconst-char-format--рекомендуется)
      - [`std::string Samp_SDK::Format(const char* format, ...)` (Деталь реализации)](#stdstring-samp_sdkformatconst-char-format--деталь-реализации)
      - [`std::string Samp_SDK::Get_String(AMX* amx, cell amx_addr)`](#stdstring-samp_sdkget_stringamx-amx-cell-amx_addr)
  - [4. **Внутренняя анатомия и архитектура SDK**](#4-внутренняя-анатомия-и-архитектура-sdk)
    - [4.1. `core.hpp`: Минималистичная основа](#41-corehpp-минималистичная-основа)
    - [**4.2. `platform.hpp` и `version.hpp`: Совместимость и метаданные**](#42-platformhpp-и-versionhpp-совместимость-и-метаданные)
    - [4.3. `function_hook.hpp`: Движок перехвата x86](#43-function_hookhpp-движок-перехвата-x86)
    - [4.4. `interceptor_manager.hpp`: Контроллер хуков AMX](#44-interceptor_managerhpp-контроллер-хуков-amx)
    - [4.5. `amx_manager.hpp`: Управление экземплярами `AMX*`](#45-amx_managerhpp-управление-экземплярами-amx)
    - [4.6. `public_dispatcher.hpp`: Маршрутизатор колбэков `Plugin_Public`](#46-public_dispatcherhpp-маршрутизатор-колбэков-plugin_public)
    - [4.7. `native.hpp`: Управление и вызов нативов плагина](#47-nativehpp-управление-и-вызов-нативов-плагина)
    - [4.8. `callbacks.hpp` \& `amx_memory.hpp`: Вызовы C++ -\> Pawn и RAII](#48-callbackshpp--amx_memoryhpp-вызовы-c---pawn-и-raii)
    - [4.9. `amx_api.hpp` \& `amx_helpers.hpp` \& `amx_defs.h`: Абстрагированный доступ к AMX](#49-amx_apihpp--amx_helpershpp--amx_defsh-абстрагированный-доступ-к-amx)
  - [5. Компиляция и развертывание](#5-компиляция-и-развертывание)
    - [Требования к архитектуре и платформе](#требования-к-архитектуре-и-платформе)
    - [Примеры команд компиляции](#примеры-команд-компиляции)
      - [**MSVC (Visual Studio)**](#msvc-visual-studio)
      - [**GCC / Clang (Linux)**](#gcc--clang-linux)
      - [**GCC / Clang (MinGW в Windows)**](#gcc--clang-mingw-в-windows)
    - [Соображения по распространению](#соображения-по-распространению)
  - [Лицензия](#лицензия)
    - [Условия использования](#условия-использования)
      - [1. Предоставленные разрешения](#1-предоставленные-разрешения)
      - [2. Обязательные условия](#2-обязательные-условия)
      - [3. Авторские права](#3-авторские-права)
      - [4. Отказ от гарантий и ограничение ответственности](#4-отказ-от-гарантий-и-ограничение-ответственности)

## 1. Введение и философия дизайна

### Проблема со стандартным C API SA-MP

API плагинов SA-MP — это программный интерфейс на языке C. Хотя он функционален и фундаментален, он представляет собой проблемы, присущие низкоуровневому программированию:
- **Ручное управление памятью:** Функции, такие как `amx_Allot` и `amx_Release`, требуют, чтобы разработчик явно выделял и освобождал память в куче AMX. Это является частым источником утечек памяти и сбоев во время выполнения.
- **Слабая типизация и ручные преобразования:** Параметры передаются в виде массива `cell`ов, что требует явных (и часто небезопасных) преобразований между `cell`, `int`, `float` и `char*`.
- **Многословность и шаблонный код:** Извлечение нескольких параметров из массива `cell* params`, работа с размерами строк и управление стеком AMX для обратных вызовов C++ в Pawn требует повторяющегося кода.
- **Хрупкость интерфейса:** Отсутствие проверки типов во время компиляции (type safety) означает, что ошибки при передаче параметров или типов могут остаться незамеченными до выполнения, что приводит к сбоям или неопределенному поведению.

### Решение SAMP SDK: Абстракция с безопасностью и производительностью

SAMP SDK решает эти проблемы, предоставляя мощный уровень абстракции на C++:
- **RAII (Resource Acquisition Is Initialization):** Автоматическое управление памятью в AMX. `Amx_Scoped_Memory` гарантирует, что выделенная память будет освобождена.
- **Безопасность типов:** Автоматическое и безопасное преобразование параметров между C++ и Pawn. Вы работаете напрямую с `int`, `float`, `std::string`.
- **Лаконичный и идиоматический синтаксис:** Макросы и шаблоны предоставляют чистый API, который больше похож на современный C++, чем на традиционный C API.
- **Надежный перехват:** Продвинутый движок хуков позволяет прозрачно перехватывать обратные вызовы Pawn (`Plugin_Public`) и динамически регистрировать нативы.
- **Высокая производительность:** Широкое использование хеширования во время компиляции (FNV1a), кеширования функций и оптимизаций `thread_local` для минимизации накладных расходов абстракций.

### Модель Header-Only: Преимущества и последствия

SDK состоит исключительно из заголовочных файлов (`.hpp`, `.h`).
- **Преимущества:**
   - **Упрощенная интеграция:** Нет необходимости собирать, компоновать или распространять библиотеки. Просто включите заголовки.
   - **Оптимизации компилятора:** Компилятор имеет полную видимость кода SDK и вашего плагина, что позволяет агрессивное встраивание (inlining) и оптимизации времени компоновки, что может привести к более быстрым бинарным файлам.
- **Последствия:**
   - **Время компиляции:** Для очень больших проектов компиляция может занимать больше времени из-за многократного включения кода SDK. Это смягчается guards включения и природой C++ "включай только то, что нужно".
   - **Макросы реализации:** Необходимость макроса `SAMP_SDK_IMPLEMENTATION` является следствием модели header-only для предотвращения переопределения символов.

## 2. Настройка и окружение

### Требования к компиляции

- **Компилятор C++:** Совместим с C++14 или выше (SDK использует функции C++14, C++17 и C++20 для конкретных оптимизаций, но C++14 является минимальным).
   - GCC (версия 7+)
   - Clang (версия 5+)
   - MSVC (Visual Studio 2015/2017/2019/2022)
- **Архитектура:** **x86 (32-бит)**. SA-MP работает исключительно на этой архитектуре. SDK включает проверки в `platform.hpp`, которые будут выдавать ошибки компиляции, если обнаружена неправильная архитектура.
- **Операционная система:** Windows или Linux.

### Рекомендуемая структура файлов

Для ясности и организации принято организовывать SDK в подпапку `samp-sdk`.

```
meu_plugin/
├── samp-sdk/
│   ├── // Другие файлы SDK
│   └── samp_sdk.hpp             // Основной заголовок для включения
│
├── src/
│   ├── main.cpp                  // Где определен SAMP_SDK_IMPLEMENTATION
│   └── my_custom_logic.cpp       // Опционально, для организации кода
│
└── CMakeLists.txt (или .vcxproj, Makefile)
```

### Основные макросы конфигурации**

Всегда определяйте эти макросы *перед* включением `samp_sdk.hpp`.

#### `SAMP_SDK_IMPLEMENTATION`

- **Цель:** Указывает компилятору, что этот файл `.cpp` должен генерировать реализации экспортных функций плагина (`Supports`, `Load`, `Unload`, `AmxLoad`, `AmxUnload`, `ProcessTick`). **SDK автоматически берет на себя экспорт этих функций, устраняя необходимость в файлах `.def` (в Windows) или объявлениях `__attribute__((visibility("default")))` (в Linux) для этих функций.**
- **Техническое влияние:** Без этого макроса компоновщик не найдет необходимые экспорты, и сервер SA-MP не сможет загрузить ваш плагин.
- **Основное правило:** **Определите этот макрос ТОЛЬКО в ОДНОМ файле `.cpp` во всем вашем проекте.** Определение его в более чем одном файле приведет к ошибке компоновки "дублирующийся символ".

```cpp
// main.cpp
#define SAMP_SDK_IMPLEMENTATION // Макрос позволяет SDK автоматически экспортировать необходимые функции.
#include "samp-sdk/samp_sdk.hpp"

// ... ваш код плагина ...
```

#### `SAMP_SDK_WANT_AMX_EVENTS`

- **Цель:** Включает функции SDK, связанные с взаимодействием со средой AMX (виртуальная машина Pawn).
- **Включенные функции:**
   - Объявление и регистрация нативных функций C++ с использованием `Plugin_Native`.
   - Обратные вызовы `OnAmxLoad(AMX* amx)` и `OnAmxUnload(AMX* amx)`.
   - Макрос `Plugin_Call` для вызова нативов самого плагина.
- **Техническое влияние:** Когда этот макрос определен, SDK автоматически собирает все ваши `Plugin_Native`ы. В функции `Supports()` флаг `SUPPORTS_AMX_NATIVES` добавляется автоматически.
- **Гибкость:** **Вы можете определить этот макрос в нескольких файлах `.cpp`**. Система статической регистрации SDK (`Native_Registrar`) объединит все нативы из разных единиц компиляции в единый глобальный список.

```cpp
// my_natives.cpp (может быть отдельным файлом от main.cpp)
#define SAMP_SDK_WANT_AMX_EVENTS // Только для включения Plugin_Native
#include "samp-sdk/samp_sdk.hpp"

Plugin_Native(MyCustomNative, AMX* amx, cell* params) {
    // ...
    return 0;
}
```

#### `SAMP_SDK_WANT_PROCESS_TICK`

- **Цель:** Включает колбэк `OnProcessTick()`, который регулярно вызывается сервером.
- **Техническое влияние:** Автоматически добавляет флаг `SUPPORTS_PROCESS_TICK` в функцию `Supports()`.

```cpp
// main.cpp
#define SAMP_SDK_IMPLEMENTATION
#define SAMP_SDK_WANT_PROCESS_TICK
#include "samp-sdk/samp_sdk.hpp"

void OnProcessTick() {
    // Логика, выполняемая при каждом "тике" сервера (например, 20 мс)
    // Будьте осторожны с тяжелыми операциями здесь!
}
```

### Определения и константы SA-MP (`samp_defs.hpp`)

Этот файл предоставляет все известные константы и лимиты SA-MP, такие как `MAX_PLAYERS`, `INVALID_PLAYER_ID`, `PLAYER_STATE_ONFOOT`, `WEAPON_DEAGLE`, `DIALOG_STYLE_LIST` и т.д. Он автоматически включается `samp_sdk.hpp` и должен использоваться для обеспечения совместимости и читаемости кода.

## 3. Подробное руководство по использованию API

### 3.1. Жизненный цикл плагина

Следующие функции являются точками входа и выхода вашего плагина, автоматически экспортируемыми SDK.

#### `bool OnLoad()`

- **Описание:** Первая функция, вызываемая сервером SA-MP после успешной загрузки вашего плагина в память.
- **Использование:** Идеально подходит для инициализации любых систем, загрузки конфигураций, открытия соединений с базами данных или загрузки модулей (`Plugin_Module`).
- **Возврат:**
   - `true`: Плагин успешно инициализирован, и загрузка продолжается.
   - `false`: Плагин не смог инициализироваться. Загрузка будет прервана, и плагин будет выгружен.

```cpp
// main.cpp
bool OnLoad() {
    Samp_SDK::Log("Инициализация MyPlugin v1.0...");

    // Пример: Загрузка модуля (подробнее в разделе 3.5)
    if (!Plugin_Module("my_database_module", "plugins/db_connector", "Модуль базы данных загружен.")) {
        Samp_SDK::Log("ОШИБКА: Не удалось загрузить модуль базы данных!");

        return false; // Прерывает загрузку основного плагина
    }

    return true;
}
```

#### `void OnUnload()`

- **Описание:** Последняя функция, вызываемая сервером SA-MP перед выгрузкой вашего плагина из памяти.
- **Использование:** Идеально подходит для очистки ресурсов, закрытия соединений, сохранения состояний и обеспечения отсутствия утечек ресурсов. SDK автоматически управляет выгрузкой модулей (`Plugin_Module`).

```cpp
// main.cpp
void OnUnload() {
    Samp_SDK::Log("MyPlugin выгружен. Освобождаются ресурсы...");
    // Для модулей, загруженных через Plugin_Module, никаких ручных действий не требуется;
    // SDK позаботится об этом.
}
```

#### `unsigned int GetSupportFlags()`

- **Описание:** Сообщает серверу SA-MP, какие функции ваш плагин поддерживает и хочет использовать.
- **Использование:** **Всегда возвращайте `SUPPORTS_VERSION` (или `SAMP_PLUGIN_VERSION`).** Другие флаги (`SUPPORTS_AMX_NATIVES`, `SUPPORTS_PROCESS_TICK`) автоматически добавляются SDK, если определены макросы `SAMP_SDK_WANT_AMX_EVENTS` и `SAMP_SDK_WANT_PROCESS_TICK`. Это упрощает обслуживание и предотвращает ошибки.

```cpp
// main.cpp
unsigned int GetSupportFlags() {
    return SUPPORTS_VERSION; // SDK автоматически добавляет необходимые флаги.
}
```

#### `void OnAmxLoad(AMX* amx)`

- **Требуется:** `SAMP_SDK_WANT_AMX_EVENTS`
- **Описание:** Вызывается каждый раз, когда новый скрипт Pawn (Gamemode или Filterscript) загружается и инициализируется на сервере.
- **Использование:** Если вам нужна специфическая логика для каждого AMX-скрипта, например, регистрация пользовательских нативов (хотя `Plugin_Native` делает это автоматически) или инициализация данных, специфичных для скрипта.

```cpp
// main.cpp (с определенным SAMP_SDK_WANT_AMX_EVENTS)
void OnAmxLoad(AMX* amx) {
    // amx представляет новый загруженный экземпляр скрипта.
    // Вы можете, например, вызвать определенную public в этом скрипте:
    // Pawn_Public_OnAmx("OnMyPluginLoaded", amx); // Гипотетический пример более продвинутого API.
    Samp_SDK::Log("Скрипт AMX загружен: %p", (void*)amx);
}
```

#### `void OnAmxUnload(AMX* amx)`

- **Требуется:** `SAMP_SDK_WANT_AMX_EVENTS`
- **Описание:** Вызывается, когда скрипт Pawn выгружается с сервера.
- **Использование:** Для очистки любых специфических ресурсов, которые вы выделили или связали с этим конкретным `AMX*`.

```cpp
// main.cpp (с определенным SAMP_SDK_WANT_AMX_EVENTS)
void OnAmxUnload(AMX* amx) {
    Samp_SDK::Log("Скрипт AMX выгружен: %p", (void*)amx);
}
```

#### `void OnProcessTick()`

- **Требуется:** `SAMP_SDK_WANT_PROCESS_TICK`
- **Описание:** Вызывается многократно при каждом "тике" сервера (обычно 20 раз в секунду или каждые 50 мс).
- **Использование:** Для непрерывной фоновой логики, таймеров, обновлений состояния, которые не зависят от событий игрока, или синхронизации данных.
- **Осторожно:** Избегайте блокирующих или вычислительно тяжелых операций здесь, так как они могут вызвать задержку на сервере.

```cpp
// main.cpp (с определенным SAMP_SDK_WANT_PROCESS_TICK)
static int tick_count = 0;

void OnProcessTick() {
    tick_count++;

    if (tick_count % 200 == 0) // Каждые 10 секунд (20 тиков/сек * 10 сек = 200 тиков)
        Samp_SDK::Log("Сервер активен %d секунд.", tick_count / 20);
}
```

### 3.2. `Plugin_Public`: Перехват событий Pawn

Макрос `Plugin_Public` является основным мостом для получения обратных вызовов Pawn в вашем коде C++.

#### Синтаксис и объявление

- `Plugin_Public(ИмяPublic, Тип1 Параметр1, Тип2 Параметр2, ...)`
- Имя функции C++, которую вы объявляете, **должно быть таким же**, как и имя колбэка Pawn (например, `OnPlayerConnect`).
- Типы параметров C++ (`int`, `float`, `std::string`) автоматически преобразуются SDK.

```cpp
// Перехват OnPlayerText(playerid, text[])
Plugin_Public(OnPlayerText, int playerid, std::string text) {
    // ...
}
```

#### Автоматический маршалинг параметров

SDK автоматически обрабатывает чтение `cell stack` AMX и преобразование в указанные типы C++:
- `int`: Преобразуется напрямую из `cell`.
- `float`: Преобразуется из `cell` с использованием `amx::AMX_CTOF`.
- `std::string`: SDK считывает адрес строки в AMX, выделяет `std::string` в C++ и копирует содержимое.

#### Управление потоком: `PLUGIN_PUBLIC_CONTINUE` vs `PLUGIN_PUBLIC_STOP`

Возвращаемое значение вашей функции `Plugin_Public` имеет решающее значение и определяет поток выполнения обратного вызова:
- `return PLUGIN_PUBLIC_CONTINUE;` (значение `1`): Указывает, что выполнение обратного вызова должно **продолжаться**. Если есть другие плагины, которые также перехватывают этот обратный вызов, они будут вызваны. Затем будет вызвана исходная `public` в скрипте Pawn.
- `return PLUGIN_PUBLIC_STOP;` (значение `0`): Указывает, что выполнение обратного вызова должно быть **прервано**. Никакие другие плагины или исходная `public` в скрипте Pawn не будут вызваны для этого события. Это идеально подходит для реализации системы, которая "переопределяет" или "блокирует" стандартное поведение SA-MP.

```cpp
// main.cpp
Plugin_Public(OnPlayerCommandText, int playerid, std::string cmdtext) {
    if (cmdtext == "/freeze") {
        Pawn_Native(TogglePlayerControllable, playerid, 0); // Замораживает игрока
        Pawn_Native(SendClientMessage, playerid, -1, Pawn_Format("Игрок %d заморожен.", playerid));

        return PLUGIN_PUBLIC_STOP; // Предотвращает обработку команды другими скриптами.
    }

    return PLUGIN_PUBLIC_CONTINUE; // Позволяет обрабатывать другие команды.
}
```

### 3.3. `Plugin_Native`: Создание нативных функций на C++

`Plugin_Native` позволяет вам расширять функциональность Pawn высокопроизводительным кодом C++.

#### Синтаксис и фиксированная сигнатура

- `Plugin_Native(ИмяНатива, AMX* amx, cell* params)`
- Функция C++ должна иметь именно эту сигнатуру: `cell ИмяНатива(AMX* amx, cell* params)`.
- `ИмяНатива` — это имя, которое будут использовать скрипты Pawn.

```cpp
// Pawn: native GetPlayerPingAverage(playerid);
Plugin_Native(GetPlayerPingAverage, AMX* amx, cell* params) {
    // ... Реализация ...
    return 0;
}
```

#### Автоматическая регистрация нативов

> [!NOTE]
> Вам **не нужно** вызывать `amx_Register` вручную. SDK обнаруживает все ваши `Plugin_Native` (в любом файле `.cpp` с `SAMP_SDK_WANT_AMX_EVENTS`) и автоматически регистрирует их в каждом загруженном AMX-скрипте (`OnAmxLoad`).

#### Извлечение параметров: `Register_Parameters` vs. `Native_Params`

##### `Register_Parameters(...)`

- **Описание:** Более простой помощник для последовательного извлечения нескольких параметров.
- **Использование:** `Register_Parameters(переменная1, переменная2, ...)`
- **Ограничения:** Для входных параметров. Не работает с необязательными параметрами или доступом по индексу.
- **Поддерживаемые типы:** `int`, `float`, `std::string`.

```cpp
// Pawn: native SetPlayerSkinAndMoney(playerid, skinid, money);
Plugin_Native(SetPlayerSkinAndMoney, AMX* amx, cell* params) {
    int playerid, skinid, money;
    Register_Parameters(playerid, skinid, money); // Извлекает 3 параметра
    
    Pawn_Native(SetPlayerSkin, playerid, skinid);
    Pawn_Native(GivePlayerMoney, playerid, money);
    
    return 1;
}
```

##### `Native_Params` (Полный API: `Get`, `Get_REF`, `Set_REF`)

- **Описание:** Класс-обертка, предоставляющий объектно-ориентированный интерфейс для доступа к параметрам натива. Более мощный для сложных сценариев.
- **Конструкция:** `Native_Params p(amx, params);`

###### `p.Count()`

- **Описание:** Возвращает количество параметров, переданных нативу.
- **Использование:** Важно для работы с необязательными параметрами.

###### `p.Get<T>(size_t index)`

- **Описание:** Извлекает входной параметр по индексу и преобразует его в тип `T`.
- **Поддерживаемые типы:** `int`, `float`, `std::string`.

```cpp
// Pawn: native GetPlayerWeaponAmmo(playerid, weaponid = -1);
Plugin_Native(GetPlayerWeaponAmmo, AMX* amx, cell* params) {
    Native_Params p(amx, params);
    
    int playerid = p.Get<int>(0);
    int weaponid = (p.Count() > 1) ? p.Get<int>(1) : Pawn_Native(GetPlayerWeapon, playerid);
    
    return Pawn_Native(GetPlayerAmmo, playerid, weaponid);
}
```

###### `p.Get_REF<T>(size_t index, T& out_value)`

- **Описание:** Получает значение параметра **ссылки** (указатель Pawn) и сохраняет его в `out_value`.
- **Использование:** Для чтения значений, переданных по ссылке из Pawn.
- **Возврат:** `true`, если адрес AMX действителен, `false` в противном случае.

```cpp
// Pawn: native CheckPlayerStats(playerid, &Float:health, &money);
Plugin_Native(CheckPlayerStats, AMX* amx, cell* params) {
    Native_Params p(amx, params);
    
    int playerid = p.Get<int>(0);
    float health = 0.0f;
    int money = 0;

    // Получает значения ссылок (Pawn передал адреса)
    p.Get_REF(1, health); // Читает значение Float:health
    p.Get_REF(2, money);   // Читает значение money
    
    Samp_SDK::Log("Игрок %d, Здоровье: %.1f, Деньги: %d", playerid, health, money);
    
    // Теперь измените их
    health = 50.0f;
    money += 100;
    
    // И записывает их обратно в память Pawn
    p.Set_REF(1, health);
    p.Set_REF(2, money);
    
    return 1;
}
```

###### `p.Get_REF<T>(size_t index)` (C++17+)

- **Описание:** Возвращает `std::optional<T>` для чтения параметра ссылки. Более безопасно для C++17 и выше.

###### `p.Set_REF<T>(size_t index, T value)`

- **Описание:** Записывает значение `T` в параметр **ссылки** Pawn (адрес, который передал Pawn).
- **Использование:** Для изменения значений, переданных по ссылке, чтобы Pawn видел изменение.
- **Возврат:** `true`, если запись прошла успешно, `false` в противном случае.

#### Возврат значений

- Ваша функция `Plugin_Native` должна возвращать `cell`.
- Чтобы вернуть `int` или `bool`, используйте приведение к `cell`.
- Чтобы вернуть `float`, используйте `amx::AMX_FTOC(мой_float)`.

```cpp
// Возвращает bool
Plugin_Native(IsPlayerSpawned, AMX* amx, cell* params) {
    Native_Params p(amx, params);
    int playerid = p.Get<int>(0);

    return (Pawn_Native(GetPlayerState, playerid) == PLAYER_STATE_SPAWNED) ? 1 : 0;
}

// Возвращает float
Plugin_Native(GetPlayerMaxHealth, AMX* amx, cell* params) {
    return amx::AMX_FTOC(100.0f); // Возвращает 100.0f
}
```

### 3.4. `Pawn_*` Макросы: Вызов функций Pawn из C++

Эти макросы являются обратными к `Plugin_Public` и `Plugin_Native`: они позволяют вашему коду C++ вызывать функции Pawn.

#### `Pawn_Native(ИмяНатива, ...)`

- **Цель:** Рекомендуемый способ вызова нативных функций SA-MP (или других плагинов) из C++.
- **Механизм:** Ищет указатель натива во внутреннем кеше SDK (заполненном `Amx_Register_Detour`). Если найден, выполняет натив в среде `Amx_Sandbox` (фальшивый, изолированный экземпляр AMX).
- **Производительность:** Наиболее эффективный, поскольку избегает дорогого поиска `publics` и напрямую взаимодействует с указателем натива.

#### `Pawn_Public(ИмяPublic, ...)`

- **Цель:** Вызывает конкретную публичную функцию в скрипте Pawn.
- **Механизм:** Перебирает экземпляры `AMX*`, управляемые `Amx_Manager`, ищет `public` по имени и выполняет ее.
- **Производительность:** Менее эффективен, чем `Pawn_Native`, из-за поиска и реального `amx_Exec`. В целом, `publics` медленнее, чем `natives`.
- **Использование:** Идеально подходит для вызова пользовательских событий в вашем Gamemode/Filterscripts, которые не являются нативами.

#### `Pawn(ИмяФункции, ...)`

- **Цель:** Макрос удобства, который пытается угадать, является ли функция нативной или публичной.
- **Механизм:** Сначала пытается вызвать как `Pawn_Native`. В случае неудачи (натив не найден) пытается вызвать как `Pawn_Public`.
- **Производительность:** Может быть немного медленнее, чем `Pawn_Native`, если функция нативная, из-за двойной попытки поиска. Для `publics` производительность такая же, как у `Pawn_Public`.
- **Использование:** Для функций, где вы не уверены, являются ли они нативными или публичными, или чтобы избежать шаблонного кода попытки одной, а затем другой.

#### Синтаксис и соглашения

- **Имя функции:** Всегда используйте имя функции Pawn **напрямую, без кавычек**. SDK преобразует его в строку внутри.
- **Параметры:** Передавайте параметры C++ напрямую.

```cpp
// Правильно:
Pawn_Native(SetPlayerPos, playerid, 100.0f, 200.0f, 300.0f); 

// Неправильно (но технически сработает из-за хеша, избегайте):
Pawn_Native("SetPlayerPos", playerid, 100.0f, 200.0f, 300.0f); 
```

#### Маршалинг входных параметров

SDK преобразует ваши типы C++ в формат `cell` AMX, управляя памятью по мере необходимости:
-   `int`, `bool`, `long`, `enum` -> `cell`
-   `float`, `double` -> `cell` (используя `amx::AMX_FTOC`)
-   `const char*`, `std::string`, `std::string_view` (C++17+) -> `cell` (выделяет память в AMX, копирует строку и передает адрес `amx_addr`)

```cpp
void Send_Formatted_Message(int playerid, const std::string& msg) {
    Pawn_Native(SendClientMessage, playerid, 0xFFFFFFFF, msg);
}
```

#### Маршалинг выходных параметров (Ссылки: `int&`, `float&`, `std::string&`)

Это ключевая функция для удобства и безопасности. Для функций Pawn, которые ожидают указатель (ссылку), SDK автоматизирует весь процесс выделения/освобождения памяти и копирования данных.

- **Как использовать:** Просто передайте вашу переменную по ссылке (`&`).
- **Механизм:** SDK выделяет память в куче AMX, передает AMX-адрес функции Pawn, ожидает, что функция Pawn заполнит этот адрес, считывает значение обратно и освобождает память AMX. Все это прозрачно.
- **С `std::string&`:** SDK выделяет стандартный буфер (256 ячеек) в AMX для строки.

```cpp
void Get_Player_Location(int playerid) {
    float x, y, z;
    int interiorid, worldid;
    std::string name;

    Pawn_Native(GetPlayerPos, playerid, x, y, z);
    Pawn_Native(GetPlayerInterior, playerid, interiorid);
    Pawn_Native(GetPlayerVirtualWorld, playerid, worldid);
    Pawn_Native(GetPlayerName, playerid, name, MAX_PLAYER_NAME);

    Samp_SDK::Log("Местоположение %s (ID:%d): Позиция(%.2f, %.2f, %.2f) Интерьер:%d Мир:%d", name.c_str(), playerid, x, y, z, interiorid, worldid);
}
```

#### Объект `Callback_Result`: Полный анализ

Все вызовы `Pawn_*` возвращают объект `Callback_Result`. Этот объект является безопасной оберткой для результата вызова Pawn.

- `Callback_Result() noexcept`: Конструктор по умолчанию, указывает на ошибку (`success_ = false`).
- `Callback_Result(bool success, cell value) noexcept`: Конструктор для успешного или неуспешного выполнения со значением.
- `explicit operator bool() const`: Позволяет использовать `if (result)` для проверки успешности вызова.
- `operator cell() const`: Позволяет преобразовать результат в `cell` для получения значения.
- `float As_Float() const`: Удобство для получения результата в виде `float`.
- `cell Value() const`: Возвращает сырое значение `cell`.
- `bool Success() const`: Возвращает `true`, если вызов Pawn был успешным.
- `int Get_Amx_Error() const`: Возвращает код ошибки AMX, если вызов не удался (0 для успеха).

```cpp
// Пример: Получение здоровья игрока.
// Натив GetPlayerHealth(playerid, &Float:health) ожидает playerid и ссылку на здоровье.
int playerid = 0; // Пример ID игрока
float player_health = 0.0f;

// Вызываем GetPlayerHealth, передавая playerid и player_health по ссылке.
// SDK позаботится о маршалинге выходного параметра 'health'.
Callback_Result result = Pawn_Native(GetPlayerHealth, playerid, player_health);

if (result) { // Проверяем, был ли вызов успешным (оператор bool)
    // Значение, возвращаемое result.As_Float() или result (оператор cell),
    // будет возвращаемым значением *натива*, а не выходным параметром.
    // Значение здоровья уже было обновлено в 'player_health' из-за маршалинга выходного параметра.
    Samp_SDK::Log("Игрок %d имеет %.1f здоровья.", playerid, player_health);
} else {
    // Вызов не удался, возможно, игрока не существует или натив не найден.
    Samp_SDK::Log("Ошибка при получении здоровья игрока %d. Код AMX: %d", playerid, result.Get_Amx_Error());
}

// Для нативов, которые возвращают значение и используют выходные параметры (менее распространено, но возможно),
// вы бы использовали оба:
// Callback_Result other_result = Pawn_Native(SomeNative, param1, output_param, param2);
// if (other_result) {
//     cell returned_value = other_result;
//     // output_param уже обновлен
// }
```

#### **3.5. `Plugin_Module`: Управление динамическими модулями**

Макрос `Plugin_Module` позволяет вашему плагину действовать как "загрузчик" для других плагинов, создавая модульную и расширяемую архитектуру. Загруженный таким образом модуль рассматривается как плагин первого класса, с собственным жизненным циклом событий, управляемым хост-плагином.

#### Синтаксис и назначение

- `Plugin_Module(const char* nome_do_arquivo_base, const char* diretorio_do_modulo, const char* mensagem_sucesso_opcional)`
- `nome_do_arquivo_base`: Базовое имя файла модуля, **без расширения** (например, для `my_module.dll` или `my_module.so` используйте `"my_module"`). SDK автоматически добавит соответствующее расширение `.dll` или `.so`.
- `diretorio_do_modulo`: Путь к директории, в которой находится файл модуля (например, `"plugins/my_custom_modules"`). **Не включайте имя файла здесь.** SDK выполнит конкатенацию полного пути (`diretorio_do_modulo/nome_do_arquivo_base.ext`).
- `mensagem_sucesso_opcional`: Необязательное сообщение, которое будет записано в консоль сервера, если модуль успешно загружен.

```cpp
// main.cpp, внутри OnLoad()

// Загружает модуль 'core_logic.dll' (или 'core_logic.so')
// который находится в папке 'modules/custom/' сервера.
if (!Plugin_Module("core_logic", "modules/custom", "Модуль Core Logic успешно загружен!"))
    return (Samp_SDK::Log("ФАТАЛЬНАЯ ОШИБКА: Не удалось загрузить модуль 'core_logic'!"), false);

// Загружает модуль 'admin_system.dll' (или 'admin_system.so')
// который находится непосредственно в папке 'plugins/' сервера.
if (!Plugin_Module("admin_system", "plugins", "Модуль администрирования активирован."))
    Samp_SDK::Log("ПРЕДУПРЕЖДЕНИЕ: Модуль администрирования не удалось загрузить.");
```

#### Жизненный цикл модуля

Модуль должен экспортировать функции `Load`, `Unload` и `Supports`, как обычный плагин. SDK управляет жизненным циклом модуля следующим образом:

- **Загрузка:** При вызове `Plugin_Module` SDK:
   1. Формирует полный путь к файлу (например, `modules/custom/core_logic.dll`).
   2. Использует `Dynamic_Library` (`LoadLibrary`/`dlopen`) для загрузки бинарного файла.
   3. **Получает указатели на ВСЕ функции жизненного цикла модуля:**
      - **Обязательные:** `Load`, `Unload`, `Supports`. Если какая-либо из них отсутствует, загрузка модуля завершается неудачей.
      - **Необязательные:** `AmxLoad`, `AmxUnload`, `ProcessTick`.
   4. Вызывает функцию `Load` модуля, передавая `ppData` основного плагина.
   5. Если `Load` возвращает `true`, модуль добавляется во внутренний список загруженных модулей.

- **Пересылка событий:** Хост-плагин **автоматически пересылает** события всем загруженным модулям.
 > [!IMPORTANT]
 > Чтобы события пересылались корректно, **хост-плагин** (тот, который вызывает `Plugin_Module`) должен быть настроен на получение этих событий.
 > - Чтобы `AmxLoad` и `AmxUnload` работали в модулях, хост-плагин должен определить макрос `SAMP_SDK_WANT_AMX_EVENTS`.
 > - Чтобы `ProcessTick` работал в модулях, хост-плагин должен определить макрос `SAMP_SDK_WANT_PROCESS_TICK`.

- **Выгрузка:** Во время `OnUnload` основного плагина SDK выгружает все модули, загруженные через `Plugin_Module`. Это происходит в **обратном порядке** загрузки (последний загруженный модуль выгружается первым), что важно для управления зависимостями и корректного освобождения ресурсов.

#### Преимущества модульности

- **Организация кода:** Разделяйте крупные плагины на меньшие, управляемые компоненты, каждый из которых находится в собственном файле модуля.
- **Повторное использование:** Создавайте универсальные модули (например, модуль базы данных, модуль расширенного логирования), которые могут использоваться разными плагинами, способствуя повторному использованию кода.
- **Независимые компоненты:** Создавайте модули, которые **полностью ориентированы на события и независимы**. Модуль может иметь свои собственные `Plugin_Native`s, перехватывать `Plugin_Public`s и иметь собственную логику `OnProcessTick`, работая как автономный плагин, но загруженный хостом.
- **Динамические обновления:** В контролируемых сценариях позволяет обновлять части системы (заменяя `.dll` или `.so` модуля) без необходимости перекомпиляции и перезапуска основного плагина или всего сервера (хотя это требует строгого управления версиями и совместимостью).

### 3.6. `Plugin_Call`: Вызов внутренних нативов плагина

Используйте `Plugin_Call` для вызова `Plugin_Native`, определенного **внутри вашего собственного плагина**.

#### Синтаксис и преимущества производительности

- `Plugin_Call(ИмяНатива, Параметр1, Параметр2, ...)`
- **Преимущество:** Избегает накладных расходов на поиск натива в массиве нативов AMX. SDK поддерживает прямую карту хешей имен к указателям функций для своих собственных нативов, что делает этот способ самым быстрым для их внутреннего вызова.
- **Требуется:** `SAMP_SDK_WANT_AMX_EVENTS`.

```cpp
// main.cpp
Plugin_Native(InternalCheckPlayerLevel, AMX* amx, cell* params) {
    int playerid;
    Register_Parameters(playerid);

    // Логика проверки уровня
    return (playerid % 2 == 0) ? 1 : 0; // Пример: четный уровень для четных ID
}

void CheckAllPlayersLevel() {
    for (int i = 0; i < MAX_PLAYERS; ++i) {
        if (Pawn_Native(IsPlayerConnected, i)) {
            if (Plugin_Call(InternalCheckPlayerLevel, i)) // Вызывает собственный натив
                Samp_SDK::Log("Игрок %d имеет высокий уровень!", i);
        }
    }
}
```

### **3.7. Утилиты SDK**

#### `Samp_SDK::Log(const char* format, ...)`

- **Описание:** Выводит сообщения в консоль сервера и в файл `server_log.txt`. Безопасная обертка для `logprintf`.
- **Использование:** Для отладки, сообщений о статусе и ошибках.
- **Механизм:** Внутри SDK получает указатель на `logprintf` через `ppData[PLUGIN_DATA_LOGPRINTF]`. Функция безопасно обрабатывает форматирование строки.

```cpp
// В любом месте вашего плагина
Samp_SDK::Log("Плагин инициализирован со значением %d и строкой '%s'.", 123, "тест");
```

#### `std::string Plugin_Format(const char* format, ...)` (Рекомендуется)

- **Описание:** Безопасно форматирует строку (аналогично `sprintf`) и возвращает `std::string`. Это **рекомендуемый и наиболее идиоматичный** способ форматирования строк для использования в вашем плагине.
- **Использование:** Идеально подходит для создания форматированных сообщений перед передачей их в `Samp_SDK::Log`, `Pawn_Native(SendClientMessage, ...)`, или для любых других потребностей в строках в вашем коде C++.
- **Механизм:** Внутри `Plugin_Format` является макросом, который вызывает `Samp_SDK::Format`. Он использует `vsnprintf` для определения точного размера форматированной строки и выделяет `std::string` достаточной емкости, предотвращая переполнение буфера.

```cpp
int playerid = 0; // Пример ID
int health = 50;
std::string status_message = Plugin_Format("Игрок %d, ваше текущее здоровье %d.", playerid, health); // Использование макроса Plugin_Format
Pawn_Native(SendClientMessage, playerid, 0xFFFFFFFF, status_message);

// Также может использоваться для внутренних логов
Samp_SDK::Log(Plugin_Format("DEBUG: Обработка статуса для ID %d", playerid).c_str());
```

#### `std::string Samp_SDK::Format(const char* format, ...)` (Деталь реализации)

- **Описание:** Основная функция реализации для форматирования строк, расположенная в пространстве имен `Samp_SDK`.
- **Использование:** Обычно не вызывается напрямую пользователем. Макрос `Plugin_Format` предоставляется как удобство для этой функции, соответствуя соглашению об именовании других макросов SDK (`Plugin_Public`, `Plugin_Native`). Вы бы вызывали ее напрямую только в том случае, если бы хотели избежать макроса `Plugin_Format` по какой-либо конкретной причине.

```cpp
// Пример того, как работает Samp_SDK::Format, но предпочтительнее Plugin_Format
std::string raw_status = Samp_SDK::Format("Только для внутреннего использования: %d.", 42);
```

#### `std::string Samp_SDK::Get_String(AMX* amx, cell amx_addr)`

- **Описание:** Преобразует адрес строки AMX (`cell amx_addr`) в `std::string` C++.
- **Использование:** В основном внутри `Plugin_Native`, когда вам нужно получить доступ к строкам, которые не преобразуются автоматически `Register_Parameters` или `Native_Params` (например, если параметр Pawn является `const` `string` и не был объявлен как `std::string` в вашем `Plugin_Native` или `Plugin_Public` для автоматического маршалинга).

```cpp
Plugin_Native(PrintRawAmxString, AMX* amx, cell* params) {
    Native_Params p(amx, params);
    cell amx_string_addr = p.Get<cell>(0); // Получает адрес строки в AMX

    std::string cpp_string = Samp_SDK::Get_String(amx, amx_string_addr);
    Samp_SDK::Log("Строка из AMX: %s", cpp_string.c_str());

    return 1;
}
```

## 4. **Внутренняя анатомия и архитектура SDK**

В этом разделе раскрываются основные механизмы SAMP SDK, исследуется его архитектура, ключевые компоненты и их взаимодействие для обеспечения высокоуровневой абстракции. Глубокое понимание этих внутренностей позволяет разработчику оптимизировать использование SDK, отлаживать сложные проблемы и даже расширять его функциональность.

### 4.1. `core.hpp`: Минималистичная основа

`Samp_SDK::Core` — это `singleton`, который служит начальной и централизованной точкой доступа к низкоуровневым данным, предоставляемым средой плагина SA-MP. Его основная ответственность — инкапсулировать и предоставлять основные функции.

- **`Samp_SDK::Core::Instance()`**:
   - **Описание:** Возвращает единственный глобальный экземпляр класса `Core`. Это шаблон проектирования `singleton`, чтобы гарантировать, что доступ к данным плагина (`ppData`) является согласованным и централизованным.
   - **Механизм:** Экземпляр инициализируется один раз, когда `Core::Instance().Load(ppData)` вызывается в функции `Load()` вашего плагина.

- **`Get_AMX_Export(PLUGIN_AMX_EXPORT_...)`**:
   - **Описание:** Обеспечивает безопасный и индексированный доступ к указателям функций AMX API. Массив `pAMXFunctions` (полученный через `ppData[PLUGIN_DATA_AMX_EXPORTS]`) содержит адреса критически важных функций, таких как `amx_Exec`, `amx_Register` и т.д.
   - **Влияние:** Вместо использования `((MyFuncType)((void**)Core::Instance().Get_AMX_Data())[INDEX])(...)`, SDK предлагает типобезопасные обертки в пространстве имен `amx::` (например, `amx::Exec(...)`), что делает код более читабельным и менее подверженным ошибкам приведения типов.
   - **Внутренний пример (`amx_api.hpp`):**
      ```cpp
      // Упрощенный фрагмент amx_api.hpp
      namespace amx {
          template <typename Func, int Index, typename... Args>
          inline auto Call(Args... args) -> decltype(std::declval<Func>()(args...)) {
              using Return_Type = decltype(std::declval<Func>()(args...));
              auto func_ptr = reinterpret_cast<Func>(Core::Instance().Get_AMX_Export(Index));

              if (SAMP_SDK_UNLIKELY(!func_ptr))
                  return (Samp_SDK::Log("[SAMP SDK] Fatal: Attempted to call AMX export at index %d, but pAMXFunctions was not loaded!", Index),
                  Samp_SDK::amx::Detail::Amx_Call_Error_Handler<Return_Type>(typename std::is_pointer<Return_Type>::type{}));

              return func_ptr(args...);
          }

          inline int Exec(AMX* amx, cell* retval, int index) {
              return Call<Exec_t, PLUGIN_AMX_EXPORT_Exec>(amx, retval, index);
          }
      } // namespace amx
      ```

- **`logprintf_ptr`**:
   - **Описание:** Указатель на функцию `logprintf` SA-MP, которая является стандартным интерфейсом для вывода сообщений в консоль сервера и в `server_log.txt`.
   - **Механизм:** `Samp_SDK::Log` — это безопасная обертка, использующая этот указатель, гарантирующая правильное отображение ваших сообщений в среде SA-MP.

### **4.2. `platform.hpp` и `version.hpp`: Совместимость и метаданные**

Эти заголовки являются основой для переносимости и оптимизации SDK, адаптируя его к различным средам компиляции и используя преимущества специфических функций современного C++.

- **Обнаружение платформы и архитектуры:**
   - **Механизм:** Использует макросы препроцессора (`#if defined(WIN32)`, `#if defined(__linux__)` и т.д.) для идентификации операционной системы.
   - **Проверка архитектуры:** Содержит `static_assert` или `#error` для обеспечения компиляции плагина для x86 (32-бит), что является критически важным требованием для совместимости с SA-MP и механизмом хукинга.
   - **Управление экспортом символов:**
      - `SAMP_SDK_EXPORT`: Макрос, определенный в `platform.hpp`, который раскрывается в `extern "C"` и, в Linux, добавляет `__attribute__((visibility("default")))`. В Windows он просто гарантирует `extern "C"`, потому что SDK использует `pragma comment(linker, "/EXPORT:...")` (для MSVC) или стандарт MinGW для экспорта основных функций.
      - Это гарантирует, что функции жизненного цикла плагина (`Supports`, `Load`, `Unload` и т.д.) будут корректно экспортированы из вашего DLL/SO, независимо от среды компиляции, **без необходимости в файлах `.def` или ручного добавления `__attribute__((visibility("default")))`** в вашу реализацию.
   - **Пример (`platform.hpp` - соответствующий фрагмент):**
      ```cpp
      #if defined(SAMP_SDK_WINDOWS)
          // Для MSVC экспорт управляется командами компоновщика pragma.
          // Это устраняет необходимость в файле .def.
          #define SAMP_SDK_EXPORT SAMP_SDK_EXTERN_C
      #else // Linux
          // Для GCC/Clang в Linux мы используем атрибут видимости
          #define SAMP_SDK_EXPORT SAMP_SDK_EXTERN_C __attribute__((visibility("default")))
      #endif
      // ... другие определения ...
      ```
   - **Пример (`samp_sdk.hpp` - соответствующий фрагмент реализации):**
      ```cpp
      #if defined(SAMP_SDK_IMPLEMENTATION)

      #if defined(SAMP_SDK_WINDOWS)
          // В Windows (MSVC) мы используем pragma comment для экспорта функций.
          // Это устраняет необходимость в файле .def.
          #pragma comment(linker, "/EXPORT:Supports=_Supports@0")
          #pragma comment(linker, "/EXPORT:Load=_Load@4")
          #pragma comment(linker, "/EXPORT:Unload=_Unload@0")
          // ... другие exports ...
      #endif

      // Реализация экспортированных функций
      SAMP_SDK_EXPORT unsigned int SAMP_SDK_CALL Supports() { /* ... */ }
      SAMP_SDK_EXPORT bool SAMP_SDK_CALL Load(void** ppData) { /* ... */ }
      SAMP_SDK_EXPORT void SAMP_SDK_CALL Unload() { /* ... */ }
      // ... другие функции ...
      #endif
      ```

- **Макросы оптимизации и предсказания ветвлений:**
   - `SAMP_SDK_FORCE_INLINE`:
      - **Механизм:** `__forceinline` (MSVC) или `__attribute__((always_inline)) inline` (GCC/Clang). Настоятельно рекомендует компилятору встроить тело функции непосредственно в место вызова, устраняя накладные расходы на реальный вызов функции.
      - **Использование:** Применяется к небольшим и критичным для производительности функциям внутри SDK.
   - `SAMP_SDK_LIKELY(x)` / `SAMP_SDK_UNLIKELY(x)`:
      - **Механизм:** `[[likely]]` / `[[unlikely]]` (C++20) или `__builtin_expect` (GCC/Clang). Подсказки компилятору о том, какой путь `if/else` с большей вероятностью будет выбран.
      - **Влияние:** Помогает компилятору генерировать более эффективный код для предсказания ветвлений (branch prediction), снижая задержку ЦП.
      - **Пример (`platform.hpp`):**
         ```cpp
         #if defined(__cplusplus) && __cplusplus >= 202002L
             #define SAMP_SDK_LIKELY(x) (x) [[likely]]
             #define SAMP_SDK_UNLIKELY(x) (x) [[unlikely]]
         #elif defined(__GNUC__) || defined(__clang__)
             #define SAMP_SDK_LIKELY(x) __builtin_expect(!!(x), 1)
             #define SAMP_SDK_UNLIKELY(x) __builtin_expect(!!(x), 0)
         #else
             #define SAMP_SDK_LIKELY(x) (x)
             #define SAMP_SDK_UNLIKELY(x) (x)
         #endif
         ```

- **Стандартные определения C++ (`SAMP_SDK_CXX14`, `SAMP_SDK_CXX_MODERN`):**
   - **Механизм:** Макросы, определенные на основе значений `__cplusplus` и `_MSVC_LANG`.
   - **Использование:** Позволяют SDK использовать более новые функции C++ (такие как `std::apply` и `if constexpr` из C++17 или `std::is_same_v` из C++17), когда они доступны, сохраняя совместимость с более старыми стандартами.
   - **Пример (`version.hpp` - использование `if constexpr`):**
      ```cpp
      // Упрощенный фрагмент public_dispatcher.hpp
      template<typename First, typename... Rest>
      inline void Get_Public_Params_Recursive(AMX* amx, int index, First& first, Rest&... rest) {
          cell value;

          if (Get_Stack_Cell(amx, index, value)) {
      #if defined(SAMP_SDK_CXX_MODERN)
                  if constexpr (std::is_same_v<decay_t<First>, std::string>)
                      first = Samp_SDK::Get_String(amx, value);
                  else if constexpr (std::is_floating_point_v<decay_t<First>>)
                      first = amx::AMX_CTOF(value);
                  else
                      first = static_cast<decay_t<First>>(value);
      #elif defined(SAMP_SDK_CXX14)
                  Assign_Parameter_By_Type(amx, &value, -1, first);
      #endif
          }

          Get_Public_Params_Recursive(amx, index + 1, rest...);
      }
      ```

### 4.3. `function_hook.hpp`: Движок перехвата x86

Этот заголовок определяет низкоуровневый механизм для выполнения хуков (перехватов) функций, который является фундаментальным для работы SDK. Он строго зависит от архитектуры x86 (32-бит).

- **`X86_Detour`**:
   - **Описание:** Класс, который инкапсулирует логику перезаписи начала функции в памяти инструкцией перехода к функции-девиатору.
   - **`JUMP_INSTRUCTION_SIZE = 5`**:
      - **Механизм:** В x86 инструкция относительного перехода (`JMP`) обычно занимает 5 байт: `0xE9` (код операции для JMP near, relative), за которым следуют 4 байта, представляющие смещение (offset) адреса цели относительно следующей инструкции.
      - **Пример инструкции:** `E9 XX XX XX XX` (где `XX` — байты смещения).
   - **`Apply(void* target, void* detour)`**:
      - **Действие:** Устанавливает хук. Сначала сохраняет `JUMP_INSTRUCTION_SIZE` оригинальных байтов функции `target` (`original_bytes_`). Затем вычисляет относительный адрес `detour` относительно `target` и перезаписывает начало `target` инструкцией `JMP`.
      - **Пример расчета относительного адреса:**
         ```cpp
         // (uintptr_t)detour_func_ - ((uintptr_t)target_func_ + JUMP_INSTRUCTION_SIZE)
         // Адрес девиатора - (Адрес цели + Размер инструкции JMP)
         ```
   - **`Revert()`**:
      - **Действие:** Удаляет хук, восстанавливая `original_bytes_` в функции `target`.
   - **`Unprotect_Memory(void* address, size_t size)`**:
      - **Механизм:** В Windows используется `VirtualProtect`; в Linux — `mprotect`. Эти системные вызовы изменяют разрешения страницы памяти, где находится функция, на `EXECUTE_READWRITE` (Windows) или `PROT_WRITE | PROT_EXEC` (Linux), что позволяет изменять код во время выполнения.
      - **Пример (`Unprotect_Memory`):**
         ```cpp
         // Упрощенный фрагмент function_hook.hpp
         #if defined(SAMP_SDK_WINDOWS)
             DWORD old_protect;
             VirtualProtect(address, size, PAGE_EXECUTE_READWRITE, &old_protect);
         #elif defined(SAMP_SDK_LINUX)
             long pagesize = sysconf(_SC_PAGESIZE);
             uintptr_t page_start = reinterpret_cast<uintptr_t>(address) & -pagesize;
             mprotect(reinterpret_cast<void*>(page_start), size + (reinterpret_cast<uintptr_t>(address) - page_start), PROT_READ | PROT_WRITE | PROT_EXEC);
         #endif
         ```

- **`Function_Hook<FuncPtr>`**:
   - **Описание:** C++ `type-safe` обертка для `X86_Detour`, гарантирующая правильность типов указателей функций.
   - `Install(void* target, void* detour)`: Инкапсулирует вызов `X86_Detour::Apply`.
   - `Uninstall()`: Инкапсулирует вызов `X86_Detour::Revert`.
   - **`Call_Original(Args... args)`**:
      - **Механизм безопасности (Guard от рекурсии):** Эта функция критически важна для предотвращения бесконечных циклов, когда девиатору необходимо вызвать исходную функцию. Она **временно удаляет хук (`detour_.Revert()`)**, вызывает исходную функцию (`Get_Original()(args...)`), а затем **переустанавливает хук (`detour_.Reapply()`)**.
      - **`static thread_local int recursion_guard`**: Счетчик, который гарантирует, что хук будет переустановлен только после завершения вызова исходной функции самого высокого уровня, что позволяет безопасно рекурсивные вызовы исходной функции (например, если исходная функция является рекурсивной). `thread_local` гарантирует, что `recursion_guard` изолирован для каждого потока, что важно в многопоточных средах.
      - **Пример (`Call_Original` с Scope_Guard):**
         ```cpp
         // Упрощенный фрагмент function_hook.hpp
         template<typename... Args>
         auto Call_Original(Args... args) -> decltype(Get_Original()(args...)) {
             static thread_local int recursion_guard = 0;

             if (recursion_guard == 0)
                 detour_.Revert();

             recursion_guard++;

             struct Scope_Guard {
                 int& guard_ref;
                 X86_Detour& detour_ref;

                 ~Scope_Guard() {
                     guard_ref--;

                     if (guard_ref == 0)
                         detour_ref.Reapply();
                 }
             };

             Scope_Guard guard{recursion_guard, detour_};
             
             return Get_Original()(args...);
         }
         ```

### 4.4. `interceptor_manager.hpp`: Контроллер хуков AMX

Этот `singleton` является нервным центром взаимодействия SDK с виртуальной машиной AMX SA-MP. Он координирует установку хуков, предоставляемых `function_hook.hpp`, в функции AMX API, предоставляемые сервером, перенаправляя поток выполнения на логику SDK.

- **`Activate()` / `Deactivate()`**:
   - **Описание:** Публичные методы для установки и удаления всех необходимых хуков. Вызываются в `OnLoad()` и `OnUnload()` вашего плагина соответственно.
   - **Механизм:** Получает указатели на функции AMX (такие как `amx_Register`, `amx_Exec` и т.д.) с помощью `Core::Instance().Get_AMX_Export(...)` и устанавливает девиаторы.
- **`int SAMP_SDK_AMX_API Amx_Register_Detour(...)`**:
   - **Захуканная функция:** `amx_Register`
   - **Цель:** Перехватывает регистрацию *всех* нативов (SA-MP, других плагинов или gamemode).
   - **Действие:** Вызывает `Interceptor_Manager::Instance().Cache_Natives()` для сохранения указателей и имен нативов во внутреннем кеше.
   - **Влияние:** Этот кеш является фундаментальным для производительности `Pawn_Native`, обеспечивая чрезвычайно быстрый поиск указателя натива вместо дорогостоящего поиска в AMX.
- **`int SAMP_SDK_AMX_API Amx_Exec_Detour(...)`**:
   - **Захуканная функция:** `amx_Exec`
   - **Цель:** **Это самый критический хук.** Он перехватывает *любое* выполнение кода в AMX, включая вызовы `publics` Pawn.
   - **Механизм перехвата `Plugin_Public`:**
      1. Когда `amx_Exec` вызывается для `public` (или `AMX_EXEC_MAIN`), выполняется `Amx_Exec_Detour`.
      2. Он получает имя `public` (используя `Get_Public_Name_By_Index` или `tl_public_name`).
      3. Запрашивает `Public_Dispatcher::Instance().Dispatch()` для проверки наличия зарегистрированных обработчиков C++ для этого имени.
      4. Если обработчики есть, он их выполняет. `Public_Dispatcher` обрабатывает `marshalling` параметров из AMX в правильные типы C++.
      5. Основываясь на возвращаемом значении `Public_Dispatcher` (`PLUGIN_PUBLIC_STOP`/`PLUGIN_PUBLIC_CONTINUE`), он решает, вызывать ли оригинальный `amx_Exec` (`Get_Amx_Exec_Hook().Call_Original(...)`) или завершить выполнение `public` Pawn.
      6. **Манипуляция стеком:** Если выполнение `public` Pawn прервано (`PLUGIN_PUBLIC_STOP`), `Amx_Exec_Detour` исправляет стек AMX (`amx->stk += amx->paramcount * sizeof(cell); amx->paramcount = 0;`), чтобы избежать несоответствий.
   - **Пример (`Amx_Exec_Detour`):**
      ```cpp
      // Упрощенный фрагмент interceptor_manager.hpp
      inline int SAMP_SDK_AMX_API Amx_Exec_Detour(AMX* amx, cell* retval, int index) {
          // ... логика определения имени public ...
          std::unique_ptr<std::string> public_name_ptr;

          if (index == AMX_EXEC_MAIN) {
              Interceptor_Manager::Instance().Set_Gamemode_Amx(amx);
              public_name_ptr = std::make_unique<std::string>("OnGameModeInit");
          }
          else if (Interceptor_Manager::Instance().Is_Gamemode_Amx(amx) && index != AMX_EXEC_CONT) {
              if (tl_public_name)
                  public_name_ptr = std::move(tl_public_name);
          }

          if (public_name_ptr) {
              cell result = 1;
              bool should_continue = Public_Dispatcher::Instance().Dispatch(FNV1a_Hash(public_name_ptr->c_str()), amx, result);
              
              if (!should_continue) {
                  if (retval)
                      *retval = result;

                  if (*public_name_ptr == "OnPlayerCommandText") {
                      if (retval)
                          *retval = 1;
                  }

                  amx->stk += amx->paramcount * sizeof(cell);
                  amx->paramcount = 0;
                  
                  return static_cast<int>(AmxError::None);
              }
          }
          
          return Get_Amx_Exec_Hook().Call_Original(amx, retval, index);
      }
      ```

- **`int SAMP_SDK_AMX_API Amx_Find_Public_Detour(...)`**:
   - **Захуканная функция:** `amx_FindPublic`
   - **Цель:** Перехватывает поиск `publics` по имени.
   - **Механизм "Ghost Publics":** Если оригинальный `amx_FindPublic` не находит `public` в Pawn, но `Public_Dispatcher` имеет зарегистрированный обработчик C++ для этого имени, этот хук возвращает `AMX_ERR_NONE` и специальный `index` (`PLUGIN_EXEC_GHOST_PUBLIC`). Это заставляет SA-MP API "думать", что `public` существует, позволяя последующему вызову `amx_Exec` (для этого специального индекса) быть перехваченным `Amx_Exec_Detour`, который затем перенаправляет его в обработчик C++.
   - **`static thread_local std::unique_ptr<std::string> tl_public_name`**: Используется для передачи имени `public` в `Amx_Exec_Detour`, когда обнаружен "ghost public", поскольку `amx_Exec` получает только индекс, а не имя.
- **`int SAMP_SDK_AMX_API Amx_Init_Detour(...)` / `Amx_Cleanup_Detour(...)`**:
   - **Захуканные функции:** `amx_Init` / `amx_Cleanup`
   - **Цель:** Управление списком активных экземпляров `AMX*`.
   - **Действие:** `Amx_Init_Detour` вызывает `Amx_Manager::Instance().Add_Amx()`, а `Amx_Cleanup_Detour` вызывает `Amx_Manager::Instance().Remove_Amx()`.

### 4.5. `amx_manager.hpp`: Управление экземплярами `AMX*`

Этот `singleton` ведет динамический учет всех виртуальных машин AMX, загруженных в данный момент на сервере. Он необходим для функций, которым нужно взаимодействовать со "всеми скриптами" или найти конкретный скрипт.

- **`std::vector<AMX*> loaded_amx_`**:
   - **Описание:** Список указателей на все экземпляры `AMX*`, которые были инициализированы (gamemode и filterscripts).
   - **Управление:** Заполняется хуками `Amx_Init_Detour` и очищается хуками `Amx_Cleanup_Detour`.
- **`std::shared_mutex mtx_` (C++17+) / `std::mutex mtx_` (C++14)**:
   - **Цель:** Защищает `loaded_amx_` от конкурентного доступа в многопоточных средах (хотя SA-MP в основном однопоточный, это хорошая практика безопасности). `std::shared_mutex` позволяет нескольким читателям одновременно, но только одному писателю.
- **`std::atomic<uint32_t> generation_`**:
   - **Цель:** Счетчик, который увеличивается каждый раз, когда AMX добавляется или удаляется.
   - **Использование:** Используется `Caller_Cache` в `callbacks.hpp` для обнаружения изменений в списке AMX, инвалидации кешей поиска `publics` и обеспечения того, чтобы вызовы `Pawn_Public` всегда работали с актуальной информацией. Это оптимизирует производительность, избегая повторных поисков в неизмененном состоянии.
- **`AMX* Find_Public(const char* name, int& index)`**:
   - **Описание:** Перебирает `loaded_amx_` (от самого нового до самого старого, что обычно помещает gamemode или наиболее релевантный filterscript первым) для поиска `public` с указанным именем.
   - **Механизм:** Использует `amx::Find_Public` для каждого экземпляра `AMX*`.
   - **Влияние:** Это основа для `Pawn_Public`.

### 4.6. `public_dispatcher.hpp`: Маршрутизатор колбэков `Plugin_Public`

Этот `singleton` является компонентом, который сопоставляет имена `publics` Pawn с соответствующими функциями C++ `Plugin_Public`.

- **`std::unordered_map<uint32_t, std::vector<Amx_Handler_Func>> handlers_`**:
   - **Ключ:** Хеш FNV1a имени `public` (например, `FNV1a_Hash_Const("OnPlayerConnect")`).
   - **Значение:** `std::vector` из `std::function<cell(AMX*)>`, где каждая `std::function` является обработчиком C++, зарегистрированным для этой `public`.
   - **Механизм:** `std::vector` позволяет регистрировать несколько `Plugin_Public` для одного и того же колбэка (например, несколько плагинов, желающих перехватить `OnPlayerCommandText`). Обработчики выполняются в обратном порядке регистрации.
- **`Public_Registrar`**:
   - **Механизм:** Это шаблонный класс, макрос `PLUGIN_PUBLIC_REGISTRATION` которого создает глобальный статический экземпляр. В статическом конструкторе (`static bool registered = [...]`) он регистрирует свой обработчик `Plugin_Public` в `Public_Dispatcher`. Это шаблон "статической регистрации во время компиляции/инициализации".
   - **Пример (`public_dispatcher.hpp`):**
      ```cpp
      #define PLUGIN_PUBLIC_REGISTRATION(name) \
          constexpr uint32_t hash_##name = Samp_SDK::Detail::FNV1a_Hash_Const(#name); \
          Samp_SDK::Detail::Public_Registrar<decltype(&name), &name, hash_##name> registrar_##name;
      ```

- **`Public_Traits` и `Wrapper()`**:
   - **Механизм:** `Public_Traits` — это шаблонный трейт, который с помощью метапрограммирования генерирует функцию `static cell Wrapper(AMX* amx)`.
   - **Цель:** Эта `Wrapper` является `Amx_Handler_Func`, которую `Public_Dispatcher` фактически хранит и вызывает. Она отвечает за:
      1. Вызов `Public_Param_Reader::Get_Public_Params(amx, args...)` для извлечения параметров из стека AMX.
      2. Вызов вашей реальной функции C++ `Plugin_Public` (`func_ptr`) с параметрами, уже преобразованными в правильные типы C++.
- **`Public_Param_Reader::Get_Public_Params(...)`**:
   - **Описание:** Набор рекурсивных шаблонных функций, которые считывают значения из стека AMX и преобразуют их в типы C++, указанные в объявлении `Plugin_Public`.
   - **Механизм:** Использует `Get_Stack_Cell()` для доступа к `cell` в стеке. Использует `if constexpr` (C++17+) или `std::is_same<T>::value` (C++14) для применения правильного преобразования (`amx::AMX_CTOF` для float, `Samp_SDK::Get_String` для string, прямое приведение для int).

### 4.7. `native.hpp`: Управление и вызов нативов плагина

Этот заголовок посвящен созданию и управлению нативами C++, которые ваш плагин предоставляет Pawn.

- **`Native_List_Holder`**:
   - **Описание:** Глобальный `singleton`, который хранит все `Plugin_Native`, объявленные в вашем плагине (из всех файлов `.cpp`, использующих `SAMP_SDK_WANT_AMX_EVENTS`).
   - **`std::vector<Native> natives_`**: Содержит объекты `Native` (которые хранят имя натива и указатель на функцию C++ `Native_Handler`).
   - **`std::unordered_map<uint32_t, Native_Handler> plugin_natives_`**: Оптимизированная по хешу карта для быстрого поиска внутренних `Plugin_Native` (используется `Plugin_Call`).
- **`Native_Registrar`**:
   - **Механизм:** Как и `Public_Registrar`, это шаблонный класс, макрос `Plugin_Native` которого создает глобальный статический экземпляр. В своем конструкторе он добавляет натив в `Native_List_Holder`.
   - **Влияние:** Позволяет объявлять `Plugin_Native` в нескольких файлах `.cpp`, не беспокоясь о ручной регистрации. Все они будут собраны автоматически.
- **`Native_Registry`**:
   - **Описание:** Вспомогательный класс, который в `OnAmxLoad` берет полный список `Native` из `Native_List_Holder` и форматирует их в массив `AMX_NATIVE_INFO`.
   - **Механизм:** Вызывает `amx::Register(amx, amx_natives_info_.data(), -1)` для регистрации всех ваших нативов в только что загруженном экземпляре AMX.
- **`Plugin_Call_Impl(...)`**:
   - **Описание:** Базовая реализация макроса `Plugin_Call`.
   - **Механизм:** Использует `Native_List_Holder::Instance().Find_Plugin_Native(native_hash)` для прямого получения указателя на функцию C++.
   - **Среда:** Выполняет натив в изолированной среде `Amx_Sandbox` для управления временным стеком и кучей, аналогично тому, как работает `Pawn_Native`.

### 4.8. `callbacks.hpp` & `amx_memory.hpp`: Вызовы C++ -> Pawn и RAII

Эти заголовки образуют основу для вызова функций Pawn из C++ (макросы `Pawn_*`) и обеспечивают безопасность памяти.

- **`Amx_Sandbox`**:
   - **Описание:** `thread_local` структура, которая имитирует минималистичную и изолированную среду `AMX` для вызовов `Pawn_Native` и `Plugin_Call`.
   - **Механизм:** Имеет собственную структуру `AMX`, `AMX_HEADER` и `std::vector<unsigned char> heap` для имитации памяти скрипта. Это позволяет вызывать `amx::Push`, `amx::Allot` и т.д. без вмешательства в состояние реально выполняющихся скриптов Pawn.
   - **`thread_local`:** Гарантирует, что каждый поток имеет свою собственную `Amx_Sandbox`, предотвращая состояния гонки, если SDK используется в многопоточном контексте (например, будущий пул потоков для не-Pawn операций).
   - **Пример (`Amx_Sandbox`):**
      ```cpp
      // Упрощенный фрагмент callbacks.hpp
      struct Amx_Sandbox {
          AMX amx;
          AMX_HEADER amx_header;
          std::vector<unsigned char> heap; // Имитированная память для стека/кучи

          Amx_Sandbox(size_t heap_size = 64 * 1024) : heap(heap_size) {
              Reset(); // Инициализирует AMX и заголовок
          }

          void Reset() {
              memset(&amx, 0, sizeof(amx));
              memset(&amx_header, 0, sizeof(amx_header));
              amx_header.magic = AMX_MAGIC;
              amx_header.file_version = MIN_FILE_VERSION;
              amx_header.amx_version = MIN_AMX_VERSION;
              amx_header.dat = reinterpret_cast<ucell>(heap.data()) - reinterpret_cast<ucell>(&amx_header);
              amx.base = reinterpret_cast<unsigned char*>(&amx_header);
              amx.data = heap.data();
              amx.callback = amx::Callback;
              amx.stp = heap.size();
              amx.stk = heap.size();
              amx.hea = 0;
              amx.flags = AMX_FLAG_NTVREG | AMX_FLAG_RELOC;
          }
      };
      ```

- **`Parameter_Processor`**:
   - **Описание:** Набор перегруженных шаблонных функций, которые управляют `marshalling` *каждого* параметра C++ в формат `cell`, ожидаемый AMX, и наоборот для выходных параметров.
   - **Обработка ввода:**
       - Для `int`, `float`, `bool`: Преобразует напрямую в `cell`.
       - Для `const char*`, `std::string`: Выделяет память в куче `Amx_Sandbox` (или реальной AMX для `Pawn_Public`), копирует строку и помещает AMX-адрес в стек.
   - **Обработка вывода (`is_output_arg`):**
       - **Механизм:** Когда аргумент является неконстантной lvalue-ссылкой (обнаруженной с помощью трейта `is_output_arg`), `Parameter_Processor` не помещает значение, а помещает *AMX-адрес* для временно выделенной `cell` в куче.
       - **`std::vector<std::function<void()>> post_call_updaters`**: После вызова натива Pawn выполняется список лямбд (`post_call_updaters`). Каждая лямбда отвечает за чтение конечного значения `cell`, выделенной в AMX, и присвоение его обратно исходной переменной C++ (например, `x = amx::AMX_CTOF(*phys_addr)`).
- **`is_output_arg`**:
   - **Механизм:** `std::integral_constant` (трейт типа), который во время компиляции оценивает, является ли тип параметра C++ изменяемой ссылкой (например, `int&`, `float&`, `std::string&`). Это позволяет `Parameter_Processor` различать входные и выходные параметры.
   - **Пример (`is_output_arg`):**
      ```cpp
      // Упрощенный фрагмент callbacks.hpp
      template <typename T>
      struct is_output_arg : std::integral_constant<bool, std::is_lvalue_reference<T>::value && !std::is_const<typename std::remove_reference<T>::type>::value> {};
      ```
- **`Amx_Scoped_Memory`**:
   - **Описание:** Класс RAII (`Resource Acquisition Is Initialization`), который инкапсулирует выделение и освобождение памяти в AMX.
   - **Механизм:** В конструкторе он вызывает `amx::Allot` для получения `amx_addr` и `phys_addr`. В деструкторе он вызывает `amx::Release` для освобождения этой памяти.
   - **Влияние:** **Критически важен для предотвращения утечек памяти в куче AMX.** Гарантирует, что временная память, используемая для строк или выходных параметров, всегда освобождается, даже если возникают исключения или ранние возвраты.

### 4.9. `amx_api.hpp` & `amx_helpers.hpp` & `amx_defs.h`: Абстрагированный доступ к AMX

Эти заголовки предоставляют фундаментальные определения и высокоуровневые инструменты для взаимодействия с Pawn.

- **`amx_defs.h`**:
   - **Содержание:** Содержит сырые определения структур AMX (`AMX`, `AMX_HEADER`), типов (`cell`, `ucell`) и перечислений ошибок (`AmxError`). Также определяет `AMX_NATIVE` и `AMX_CALLBACK`.
   - **`SAMP_SDK_PACKED`**: Использует атрибуты упаковки (`#pragma pack(push, 1)` / `__attribute__((packed))`), чтобы гарантировать, что структуры AMX имеют правильное расположение в памяти, что крайне важно для взаимодействия.
- **`Samp_SDK::amx::Call<Func, Index, ...>`**:
   - **Описание:** Основная шаблонная функция для вызова функций AMX API, предоставляемых сервером.
   - **Механизм:** Получает указатель на функцию через `Core::Instance().Get_AMX_Export(Index)` и вызывает ее. Централизует обработку ошибок, если указатель на функцию недоступен.
   - **Влияние:** Преобразует низкоуровневые вызовы (`Core::Instance().Get_AMX_Export(PLUGIN_AMX_EXPORT_Exec)`) в идиоматические и типобезопасные вызовы C++ (`amx::Exec`).
- **`Samp_SDK::amx::AMX_CTOF(cell c)` / `AMX_FTOC(float f)`**:
   - **Описание:** Основные функции для преобразования значений `cell` в `float` и наоборот, выполняя побитовую переинтерпретацию памяти.
   - **`static_assert`:** Включают `static_assert` для гарантии того, что `sizeof(cell) == sizeof(float)` во время компиляции, предотвращая ошибки на платформах с различными размерами типов.
- **`Samp_SDK::Get_String(AMX* amx, cell amx_addr)`**:
   - **Описание:** Вспомогательная функция для преобразования AMX-адреса строки в `std::string`.
   - **Механизм:** Сначала получает физический адрес (`cell* phys_addr`) строки в AMX с помощью `amx::Get_Addr`. Затем использует `amx::STR_Len` для определения длины и `amx::Get_String` для копирования байтов в `std::string`.
- **`std::string Samp_SDK::Format(const char* format, ...)`**:
   - **Описание:** Базовая функция форматирования строк (подобная `printf`) для SDK.
   - **Механизм:** Использует `vsnprintf` в два прохода: сначала для определения необходимого размера строки, а затем для форматирования строки в динамически выделенную `std::string`. Это предотвращает переполнение буфера.

## 5. Компиляция и развертывание

### Требования к архитектуре и платформе

- Ваш плагин **ДОЛЖЕН** быть скомпилирован для архитектуры **x86 (32-бит)**. Механизм хукинга SDK специфичен для этой архитектуры.
- Поддерживаемые платформы: Windows (.dll) и Linux (.so).

### Примеры команд компиляции

#### **MSVC (Visual Studio)**

1. Создайте новый проект "Библиотека динамической компоновки (DLL)".
2. В параметрах проекта установите "Платформа решения" на **x86**.
3. Убедитесь, что стандарт языка C++ не ниже C++14.

#### **GCC / Clang (Linux)**

```bash
# Для плагина с именем 'my_plugin.so' из 'main.cpp'
g++ -m32 -shared -std=c++17 -O2 -fPIC -Wall -Wextra -Wl,--no-undefined main.cpp -o my_plugin.so
```
- `-m32`: Компилирует для 32-битной архитектуры.
- `-shared`: Создает общую библиотеку (`.so`).
- `-std=c++17`: Устанавливает стандарт C++ на C++17 (может быть `c++14` или `c++20`).
- `-O2`: Уровень оптимизации 2.
- `-fPIC`: Генерирует позиционно-независимый код, необходимый для общих библиотек.
- `-Wall -Wextra`: Включает дополнительные предупреждения для обнаружения ошибок.
- `-Wl,--no-undefined`: Предотвращает создание библиотеки, если есть неопределенные символы.

#### **GCC / Clang (MinGW в Windows)**

```bash
# Для плагина с именем 'my_plugin.dll' из 'main.cpp'
g++ -m32 -shared -std=c++17 -O2 -static-libstdc++ -static-libgcc -Wl,--no-undefined main.cpp -o my_plugin.dll
```
- `-static-libstdc++`: Статически линкует стандартную библиотеку C++. Важно для предотвращения зависимости вашего плагина от специфичных для компилятора DLL времени выполнения, которые могут отсутствовать в системе пользователя.
- `-static-libgcc`: Статически линкует библиотеку GCC.

### Соображения по распространению

- **Имя файла:** Ваш плагин должен иметь расширение `.dll` (Windows) или `.so` (Linux). Например: `my_plugin.dll`.
- **Местоположение:** Поместите скомпилированный файл в папку `plugins/` вашего сервера SA-MP.
- **server.cfg:** Добавьте имя вашего плагина (если Windows, без расширения) в строку `plugins` в `server.cfg`.
   ```
   plugins my_plugin (если Linux, my_plugin.so)
   ```

## Лицензия

Copyright © **SA-MP Programming Community**

Данное программное обеспечение лицензируется в соответствии с условиями лицензии MIT ("Лицензия"); вы можете использовать это программное обеспечение в соответствии с условиями Лицензии. Копию Лицензии можно получить по адресу: [MIT License](https://opensource.org/licenses/MIT)

### Условия использования

#### 1. Предоставленные разрешения

Настоящая лицензия бесплатно предоставляет любому лицу, получающему копию данного программного обеспечения и связанных с ним файлов документации, следующие права:
* Использовать, копировать, изменять, объединять, публиковать, распространять, сублицензировать и/или продавать копии программного обеспечения без ограничений
* Разрешать лицам, которым предоставляется программное обеспечение, делать то же самое при соблюдении указанных ниже условий

#### 2. Обязательные условия

Все копии или существенные части программного обеспечения должны включать:
* Вышеуказанное уведомление об авторских правах
* Данное уведомление о разрешении
* Приведенное ниже заявление об отказе от ответственности

#### 3. Авторские права

Программное обеспечение и вся связанная с ним документация защищены законами об авторских правах. **SA-MP Programming Community** сохраняет за собой оригинальные авторские права на программное обеспечение.

#### 4. Отказ от гарантий и ограничение ответственности

ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ "КАК ЕСТЬ", БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ГАРАНТИЯМИ ТОВАРНОЙ ПРИГОДНОСТИ, ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ И НЕНАРУШЕНИЯ ПРАВ.

НИ ПРИ КАКИХ ОБСТОЯТЕЛЬСТВАХ АВТОРЫ ИЛИ ПРАВООБЛАДАТЕЛИ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ ЗА ЛЮБЫЕ ПРЕТЕНЗИИ, УБЫТКИ ИЛИ ИНУЮ ОТВЕТСТВЕННОСТЬ, БУДЬ ТО В СИЛУ ДОГОВОРА, ДЕЛИКТА ИЛИ ИНЫМ ОБРАЗОМ, ВОЗНИКАЮЩИЕ ИЗ, ИЗ-ЗА ИЛИ В СВЯЗИ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ ИЛИ ИСПОЛЬЗОВАНИЕМ ИЛИ ИНЫМИ ДЕЙСТВИЯМИ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ.

---

Для подробной информации о лицензии MIT посетите: https://opensource.org/licenses/MIT